ALIASES = "rv_param_timer=@param Timer: Pointer to timer struct."
ALIASES += "rv_param_ch_14=@param Channel: Integer to specify the channel, 1 to 4, negative for complimentary output channels."
ALIASES += "rv_apb_check=Constant to check if non-unitary prescaling has been applied to advanced peripheral bus"
ALIASES += "rv_single_func_convenience=This provides some convenience in that it lets the developer use a single call to manage a PWM output channel with the same function, instead of having different functions for each channel."
ALIASES += "rv_upd_via_psc_arr=This is performed by updating ARR value while keeping PSC constant. PSC value and peripheral bus clock determine the base frequency. See @ref GetBaseFreq \"GetBaseFreq\" for further info."
ALIASES += "rv_frm_period=\f$Period = (ARR+1) / Base Frequency \f$"
ALIASES += "rv_frm_arr=\f$ARR = Base Frequency * Period - 1\f$"
ALIASES += "rv_frm_freq=\f$Frequency = Base Frequency / (ARR+1) \f$"
ALIASES += rv_otf_arr_base_calc{1}="\1 is calculated on the fly using the ARR and base frequency. See @ref GetBaseFreq \"GetBaseFreq\" for further info."
ALIASES += rv_ccr_bit_action{1}="Fetches the bit mask of the selected channel from the array @ref TimerChannel_EN \"TimerChannel_EN\" and uses that to \1 the designated CCER register bit."
ALIASES += "rv_ch_14_avoid_fail=Channel parameter is ensured to be a valid integer value beforehand to avoid failure."
ALIASES += "rv_ch_ret_min_1_on_fail=In case of an invalid input, -1.0 is returned."
ALIASES += rv_req_xreg{1}="Note that this will only work if the timer has the \1 register."
ALIASES += rv_bdtr_bit_toggle{2}="\1 the \2 bit in the break and dead time register of the timer."
ALIASES += "rv_tim_ch_acq=the pointer to which is acquired with a call to @ref ChannelSelector \"ChannelSelector\" with the timer struct pointer and the corresponding element of the CCR variable offset array @ref TimerChannel_CCR \"TimerChannel_CCR\"."
ALIASES += rv_action_periph_it_flag{3}="\1 the \2 interrupt flag of the \3."
ALIASES += rv_clear_tim_it_flag_det{1}="\1 interrupt flag is cleared software-wise with the logical NOT of the flag's timer status register bitmask."
ALIASES += "rv_periph_it_ret=1 if the interrupt flag is set. Returns 0 otherwise."
ALIASES += rv_toggle_periph_it{3}="\1 the \2 interrupt of \3."
ALIASES += rv_tim_it_enable_det{1}="The enable bit in the timer control register is set after clearing the \1 interrupt flag."
ALIASES += rv_tim_it_disable_det{1}="The \1 interrupt is disabled by clearing the enable bit in the timer control register."
ALIASES += rv_triple_action{2}="\1 the \2."
ALIASES += rv_bool_ret_en{1}="1 if the \1 is enabled, 0 otherwise."
ALIASES += "rv_obvious=Self-explanatory code, nothing to elaborate."
ALIASES += rv_bit_is_set_det{1}="\1 bit is isolated from the register with its bitmask and compared to the same bitmask instead of shifting since the amount of shift would depend on the bitmask."
ALIASES += rv_def_req_device{1}="Requires the device specific macro \1 to be defined."
ALIASES += rv_def_req{1}="Requires @ref \1 \"\1\" to be defined."
ALIASES += rv_not_def_req{1}="Requires @ref \1 \"\1\" to be NOT defined."
ALIASES += "rv_param_fp_isr=@param ISR: Pointer to ISR, a void-parameter void-return function."
ALIASES += rv_tim_assign_isr_conv{1}="Assigns a function to the designated flag handler for the \1 interrupt of a timer."
ALIASES += rv_tim_assign_isr_plain{1}="Assigns a function to the \1 IRQ handler."
ALIASES += rv_conv_isr_assign_det{1}="Assigns the the ISR to the designated handler for @ref Check_IT \"Check_IT\" to use inside the IRQ if the selected timer indeed has the \1 interrupt flag, branches to @ref InfiniteLoopOfError \"InfiniteLoopOfError\" otherwise."
ALIASES += rv_irq_imp_bri{1}="\1 IRQ implementation."
ALIASES += "rv_irq_imp_det=Performs a call to @ref Check_IT \"Check_IT\" for each flag set with its interrupt enabled if @ref HIERODULE_TIM_CONVENIENT_IRQ \"HIERODULE_TIM_CONVENIENT_IRQ\" is enabled, uses the plain ISR handler implemented by the user otherwise."
ALIASES += rv_irq_imp_solo_det{1}="Performs a call to @ref Check_IT \"Check_IT\" for the \1 interrupt if @ref HIERODULE_TIM_CONVENIENT_IRQ \"HIERODULE_TIM_CONVENIENT_IRQ\" is enabled, uses the plain ISR handler implemented by the user otherwise."
ALIASES += rv_fp_conv_isr{2}="ISR handler for \1 interrupt flag of timer \2"
ALIASES += rv_fp_plain_isr{1}="Pointer to the \1 IRQ routine."
ALIASES += rv_refer_to_usage{1}="Refer to the @ref \1 \"Usage\" page for directives."
ALIASES += rv_global_private_brief{1}="Elements of the module that \1 confined to the scope of the compilation unit."
ALIASES += rv_corresponds_exc_irqs{1}="Perfectly corresponds to the module's \1 file, except the IRQ handlers."
ALIASES += "rv_irq_defs_eof=IRQ definitions with custom ISR implementations are also included at the end of the file."
ALIASES += "rv_inc_main=Device-specific macro constants and type definitions are imported with an include directive to main.h, where the device driver headers are assumed to be included."
ALIASES += rv_inc_headers{2}="\1 also included for \2."
ALIASES += rv_common_wrap_field{1}="This field is meant to be set via @ref \1 \"\1\", changing it manually may result in unexpected behavior."
ALIASES += rv_param_wrapper_ptr{1}"=@param Wrapper Pointer to the \1 wrapper."
ALIASES += rv_bit_assumption_usart{1}="\1 flag in the USART control register is assumed to be already set."
ALIASES += "rv_module_no_init=The module does not address peripheral configuration and initialization, it is assumed those are performed beforehand."
ALIASES += rv_static_wrap_det{1}="Implements the routines defined in the header file and routines necessary for those in the background. Pointers of \1 wrappers are also defined here."
ALIASES += rv_wrapper_brief{3}="Struct that keeps variables for the \1, a pointer to the \2 peripheral and a pointer to the ISR for \3."
ALIASES += "rv_wrapper_det=Used by all routines in the module.\n Alias typedefs for custom pointers are not defined, since they're not used excessively in the module."
ALIASES += rv_wrapper_isr_det{1}="Notice this points to a function with a \1 parameter, ergo the ISR assigned must be declared accordingly, even if it won't use the received byte in its definition."
ALIASES += "rv_static_for_irq=Meant to be used in IRQ bodies and not for custom implementations, hence the reason it's static."

ALIASES += rv_init_wrapper_brief_param{2}="@brief Initializes a wrapper for the specified \1 peripheral. @param \2 \1 peripheral of the wrapper."
ALIASES += "rv_init_wrapper_ret=Double pointer to the initialized wrapper."
ALIASES += rv_wrapper_future_release{2}="The wrapper pointer gets a new address allocated, to be freed at some future point via @ref \2 \"\2\", hence the reason a pointer is used for the wrapper; likewise, a double pointer is used to return it by reference.\n Device specific checks are performed for the \1 peripheral specified."

ALIASES += rv_wrapper_warn_release_det{1}="Using a released \1 wrapper or its fields may result in unexpected behavior.\n Keep in mind this clears up the \1 wrapper pointer in this file scope; it is recommended to free your double pointer to the wrapper, likewise."

ALIASES += "rv_adc_irq_handler_det=If the wrapper to an ADC peripheral is allocated and flag checks are true, data holder in the assigned wrapper gets updated. If the wrapper has an ISR assigned, that is also invoked.\n Notice the filter is optional."

ALIASES += rv_usage_irq{1}="Also notice that the \1 IRQs are defined in the module's source file. The compiler will throw a multiple definition error if an IRQ is defined somewhere else."

ALIASES += rv_usage_wrapper_double_ptr{1}="It has to be a double pointer, since the wrapper initializer passes you the wrapper pointer defined in the module by reference. The wrapper instance is handled in the module with a pointer and not with a variable of type @ref \1 \"\1\", since you use pointers for dynamic memory allocation."
ALIASES += rv_usage_wrapper_isr{2}="Secondly, you need a void function with a \1 parameter for the \2 ISR. You might as well just pass NULL if you intend to use the received data somewhere else. Or you can even maintain an array for the function pointers (i.e. void (\*)(\1)) to switch between ISRs on the fly."

ALIASES += rv_usage_wrapper_release{2}="You can \"release\" the instance of your wrapper to free memory: @code{c} HIERODULE_\1_ReleaseWrapper(*\2); @endcode Keep in mind this only frees the wrapper pointer in the module and not your double pointer that points to it. It's best to free and nullify that, as well: @code{c} free(\2); @endcode @code{c}\2 = NULL; @endcode Notice that trying to access a freed memory address might turn out ugly for your run-time. However, you can reuse your double pointer to re-initialize the \1 peripheral after releasing it."

ALIASES += rv_tim_reserved{1}="Won't be compiled if @ref HIERODULE_TIM_RESERVED \"HIERODULE_TIM_RESERVED\" equals \1"

