<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hierodule: SPI Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hierodule
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
   <div id="projectbrief">Utility module set for STM32 MCUs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_s_p_i__usage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SPI Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_SPI_USAGE"></a></p>
<p>With this module, you can</p><ul>
<li>Initiate an SPI transmission as master.</li>
<li>Unidirectionally parse the data received, which is kept in a ring buffer.</li>
<li>Set up the data to be transmitted during the next transmission.</li>
<li>Assign callback routines to be invoked at the end of a transmission as master or slave.</li>
</ul>
<p><a class="el" href="struct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper.html">HIERODULE_SPI_Wrapper</a> is the main item in the module, with which you can access the variables related to the ring buffer and use the module routines to implement your SPI comm procedure.</p>
<p>The module does not address peripheral configuration and initialization, it is assumed those are performed beforehand. Make sure to have configured your SPI peripheral accordingly. Only full duplex slave and master modes are supported for 8-bit long transmissions. <br  />
NSS a.k.a. chip selection is not handled by the module, you might want to simply assign a GPIO pin to each slave device, or use a multiplexer, as the master. You might as well just use the hardware input/output functionality of the peripheral. <br  />
Make sure to use external PU/PD resistors on the data and chip select lines, especially at higher baud rates. Consult the device manual the manufacturer provides for further directives.</p>
<p>Also notice that the SPI IRQs are defined in the module's source file. The compiler will throw a multiple definition error if an IRQ is defined somewhere else.</p>
<p>To start using the module, first thing you need is a double pointer to <a class="el" href="struct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper.html">HIERODULE_SPI_Wrapper</a> to create an instance for the SPI peripheral. </p><div class="fragment"><div class="line"><a class="code" href="struct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper.html">HIERODULE_SPI_Wrapper</a> **My_SPI1_Wrapper = NULL;</div>
<div class="ttc" id="astruct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper_html"><div class="ttname"><a href="struct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper.html">HIERODULE_SPI_Wrapper</a></div><div class="ttdoc">Struct that keeps variables for the data buffers, a pointer to the SPI peripheral,...</div><div class="ttdef"><b>Definition:</b> <a href="hierodule__spi_8h_source.html#l00042">hierodule_spi.h:43</a></div></div>
</div><!-- fragment --><p> It has to be a double pointer, since the wrapper initializer passes you the wrapper pointer defined in the module by reference. The wrapper instance is handled in the module with a pointer and not with a variable of type <a class="el" href="struct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper.html">HIERODULE_SPI_Wrapper</a>, since you use pointers for dynamic memory allocation. <br  />
<br  />
Next, define callback routine to be called at the end of a transmission. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TC_Handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * This will be performed at the end of a transmission.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> <br  />
You only need to implement the callback routines according to the device role and the consequent procedure, and let the module handle the communication. It's possible to switch to a different callback routine for a transmission mode as well, as long as the pointer to the routine is of type void(*)(void). <br  />
You can also just pass a null pointer if you do not need anything done at the end of a certain transmission mode. <br  />
Keep in mind that the callback routine will be Called at the end of an entire transmission in master mode. As for slave mode, the routine will get invoked at the end of each byte transmission.</p>
<p><br  />
<br  />
Next, initialize the wrapper as master for SPI1 with the callback routine and an arbitrary RX buffer size, 24 for this instance. </p><div class="fragment"><div class="line">My_SPI1_Wrapper = <a class="code" href="group___s_p_i___public.html#ga04bdf414e9ffd42b17790294648d9703">HIERODULE_SPI_InitWrapper</a> (SPI1, 1, 24, TC_Handler);</div>
<div class="ttc" id="agroup___s_p_i___public_html_ga04bdf414e9ffd42b17790294648d9703"><div class="ttname"><a href="group___s_p_i___public.html#ga04bdf414e9ffd42b17790294648d9703">HIERODULE_SPI_InitWrapper</a></div><div class="ttdeci">HIERODULE_SPI_Wrapper ** HIERODULE_SPI_InitWrapper(SPI_TypeDef *_SPI, uint8_t Mode, uint16_t RX_BufferSize, void(*TC_Handler)(void))</div><div class="ttdoc">Initializes a wrapper for the specified SPI peripheral.</div><div class="ttdef"><b>Definition:</b> <a href="hierodule__spi_8c_source.html#l00123">hierodule_spi.c:123</a></div></div>
</div><!-- fragment --><p> <br  />
Or, in case you intend to use the peripheral in slave mode, simply call the initializer with a mode parameter value of 0. </p><div class="fragment"><div class="line">My_SPI1_Wrapper = <a class="code" href="group___s_p_i___public.html#ga04bdf414e9ffd42b17790294648d9703">HIERODULE_SPI_InitWrapper</a> (SPI1, 0, 24, TC_Handler);</div>
</div><!-- fragment --><p><br  />
Now you're all set. If you've initialized the wrapper in slave mode, the peripheral should be able to handle the incoming transmissions from masters. Depending on your implementation, you might want to load an initial value to the data register, an exclamation mark for example: </p><div class="fragment"><div class="line"><a class="code" href="group___s_p_i___public.html#ga5aca3286f5e59add256abebcf92e3fa1">HIERODULE_SPI_TransmitByte</a>(*My_SPI1_Wrapper, <span class="charliteral">&#39;!&#39;</span>);</div>
<div class="ttc" id="agroup___s_p_i___public_html_ga5aca3286f5e59add256abebcf92e3fa1"><div class="ttname"><a href="group___s_p_i___public.html#ga5aca3286f5e59add256abebcf92e3fa1">HIERODULE_SPI_TransmitByte</a></div><div class="ttdeci">void HIERODULE_SPI_TransmitByte(HIERODULE_SPI_Wrapper *Wrapper, uint8_t Byte)</div><div class="ttdoc">Writes a byte into the data register of the SPI peripheral.</div><div class="ttdef"><b>Definition:</b> <a href="hierodule__spi_8c_source.html#l00114">hierodule_spi.c:114</a></div></div>
</div><!-- fragment --><p> Likewise, use <a class="el" href="group___s_p_i___public.html#ga5aca3286f5e59add256abebcf92e3fa1">HIERODULE_SPI_TransmitByte</a> to set up the data response for the next transmission inside your transmission complete callback, which is invoked <em>whenever the peripheral receives a byte at the MOSI line and sends its respond through the MISO line</em>. You can parse the received bytes via <a class="el" href="group___s_p_i___public.html#ga44178b750190e7f6626f1969f5db3f7b">HIERODULE_SPI_GetNextByte</a>. <br  />
You can also manipulate the transmit buffer to determine the next response with <a class="el" href="struct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper.html#a304ac9f0e1ae1a28f817de51373834af">TX_Buffer</a> and <a class="el" href="struct_h_i_e_r_o_d_u_l_e___s_p_i___wrapper.html#a1e465dcab3c06031f1432d463134c31e">TX_Counter</a>. Keeping different byte arrays and swapping between them on the fly with the received data in regard might be a good idea.</p>
<p><br  />
<br  />
To start a transmission as master, call the master transmit routine with your wrapper, a byte array and the number of bytes to be transmitted. </p><div class="fragment"><div class="line">uint8_t SPI1_TX_Buffer[6];</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> * ...</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group___s_p_i___public.html#ga7be4597eac14ce7d18d1657ad28c8109">HIERODULE_SPI_TransmitPackage</a>(*My_SPI1_Wrapper, SPI1_TX_Buffer, 6);</div>
<div class="ttc" id="agroup___s_p_i___public_html_ga7be4597eac14ce7d18d1657ad28c8109"><div class="ttname"><a href="group___s_p_i___public.html#ga7be4597eac14ce7d18d1657ad28c8109">HIERODULE_SPI_TransmitPackage</a></div><div class="ttdeci">void HIERODULE_SPI_TransmitPackage(HIERODULE_SPI_Wrapper *Wrapper, uint8_t *TX_Buffer, uint32_t Size)</div><div class="ttdoc">Starts a transmission as the master.</div><div class="ttdef"><b>Definition:</b> <a href="hierodule__spi_8c_source.html#l00204">hierodule_spi.c:204</a></div></div>
</div><!-- fragment --><p> In this case, your transmission complete callback is invoked <em>when the entire transmission sequence is completed and the peripherals have returned to the idle state</em>. Again, you can parse the received bytes via <a class="el" href="group___s_p_i___public.html#ga44178b750190e7f6626f1969f5db3f7b">HIERODULE_SPI_GetNextByte</a>. <br  />
<br  />
You can "release" the instance of your wrapper to free memory:</p><div class="fragment"><div class="line"><a class="code" href="group___s_p_i___public.html#gad40bcb8425b4a9cc731f1c04f69b8616">HIERODULE_SPI_ReleaseWrapper</a>(*My_SPI1_Wrapper); </div>
<div class="ttc" id="agroup___s_p_i___public_html_gad40bcb8425b4a9cc731f1c04f69b8616"><div class="ttname"><a href="group___s_p_i___public.html#gad40bcb8425b4a9cc731f1c04f69b8616">HIERODULE_SPI_ReleaseWrapper</a></div><div class="ttdeci">void HIERODULE_SPI_ReleaseWrapper(HIERODULE_SPI_Wrapper *Wrapper)</div><div class="ttdoc">Frees the memory allocated to an SPI wrapper.</div><div class="ttdef"><b>Definition:</b> <a href="hierodule__spi_8c_source.html#l00193">hierodule_spi.c:193</a></div></div>
</div><!-- fragment --><p> Keep in mind this only frees the wrapper pointer in the module and not your double pointer that points to it. It's best to free and nullify that, as well:</p><div class="fragment"><div class="line">free(My_SPI1_Wrapper); </div>
</div><!-- fragment --><div class="fragment"><div class="line">My_SPI1_Wrapper = NULL; </div>
</div><!-- fragment --><p> Notice that trying to access a freed memory address might turn out ugly for your run-time. However, you can reuse your double pointer to re-initialize the SPI peripheral after releasing it. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
