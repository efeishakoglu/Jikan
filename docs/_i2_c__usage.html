<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hierodule: I2C Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hierodule<span id="projectnumber">&#160;1.6.2</span>
   </div>
   <div id="projectbrief">Utility module set for STM32 MCUs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_i2_c__usage.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">I2C Module</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__i2_c___u_s_a_g_e"></a></p>
<p>With this module, you can</p><ul>
<li>Initiate an I2C transmission as master transmitter or master receiver.</li>
<li>Unidirectionally parse the data received as slave receiver, which is kept in a ring buffer.</li>
<li>Set up the data to be transmitted as master or slave during the next transmission.</li>
<li>Assign callback routines to be invoked at the end of a transmission, for the four transmission modes.</li>
</ul>
<p><a class="el" href="struct_h_i_e_r_o_d_u_l_e___i2_c___wrapper.html">HIERODULE_I2C_Wrapper</a> is the main item in the module, with which you can access the variables related to the ring buffer and use the module routines to implement your I2C comm procedure.</p>
<p>The module does not address peripheral configuration and initialization, it is assumed those are performed beforehand. Make sure to have configured your I2C peripheral accordingly. Also, make sure to use external pull up resistors since most of the time internal pull-ups won't be strong enough for high speed. Typically, a 4.7kÎ© resistor on each line should be enough but it's best to consult the device manual to find out the recommended resistance value for the I2C lines.</p>
<p>Also notice that the I2C IRQs are defined in the module's source file. The compiler will throw a multiple definition error if an IRQ is defined somewhere else.</p>
<p>To start using the module, first thing you need is a double pointer to <a class="el" href="struct_h_i_e_r_o_d_u_l_e___i2_c___wrapper.html">HIERODULE_I2C_Wrapper</a> to create an instance for the I2C peripheral. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="struct_h_i_e_r_o_d_u_l_e___i2_c___wrapper.html">HIERODULE_I2C_Wrapper</a> **My_I2C1_Wrapper = NULL;</div>
<div class="ttc" id="astruct_h_i_e_r_o_d_u_l_e___i2_c___wrapper_html"><div class="ttname"><a href="struct_h_i_e_r_o_d_u_l_e___i2_c___wrapper.html">HIERODULE_I2C_Wrapper</a></div><div class="ttdoc">Struct that keeps variables for the data buffers, a pointer to the I2C peripheral,...</div><div class="ttdef"><b>Definition</b> <a href="hierodule__i2c_8h_source.html#l00081">hierodule_i2c.h:82</a></div></div>
</div><!-- fragment --><p> It has to be a double pointer, since the wrapper initializer passes you the wrapper pointer defined in the module by reference. The wrapper instance is handled in the module with a pointer and not with a variable of type <a class="el" href="struct_h_i_e_r_o_d_u_l_e___i2_c___wrapper.html">HIERODULE_I2C_Wrapper</a>, since you use pointers for dynamic memory allocation. <br  />
<br  />
Next, define the four callback routines to be called at the end of transmissions. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> SRX1_Handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * This will be performed at the end of a slave receiver mode transmission.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MTX1_Handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * This will be performed at the end of a master transmitter mode transmission.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> STX1_Handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * This will be performed at the end of a slave transmitter mode transmission.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MRX1_Handler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"> * This will be performed at the end of a master receiver mode transmission.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> <br  />
Unlike other modules, callback functions you assign to the wrapper do not follow the routine-per-interrupt scheme, a.k.a. an ISR. In other words, you do not assign routines to be invoked at each received or transmitted byte, or to handle interrupt signals. The four routines you provide will only be invoked at the end of an I2C transmission. <br  />
You only need to implement the callback routines according to the device role and the consequent procedure, and let the module handle the communication. It's possible to switch to a different callback routine for a transmission mode as well, as long as the pointer to the routine is of type void(*)(void). <br  />
You can also just pass a null pointer if you do not need anything done at the end of a certain transmission mode. <br  />
<br  />
Next, initialize the wrapper with the callback routines and an arbitrary SRX buffer size, 24 for this instance. </p><div class="fragment"><div class="line">My_I2C1_Wrapper = <a class="code hl_function" href="group___i2_c___public.html#ga84a0b2df32dc90f8b464160f74fa0ae9">HIERODULE_I2C_InitWrapper</a>(I2C1, 24, SRX1_Handler, MTX1_Handler, STX1_Handler, MRX1_Handler);</div>
<div class="ttc" id="agroup___i2_c___public_html_ga84a0b2df32dc90f8b464160f74fa0ae9"><div class="ttname"><a href="group___i2_c___public.html#ga84a0b2df32dc90f8b464160f74fa0ae9">HIERODULE_I2C_InitWrapper</a></div><div class="ttdeci">HIERODULE_I2C_Wrapper ** HIERODULE_I2C_InitWrapper(I2C_TypeDef *_I2C, uint16_t SRX_BufferSize, void(*SRX_Handler)(void), void(*MTX_Handler)(void), void(*STX_Handler)(void), void(*MRX_Handler)(void))</div><div class="ttdoc">Initializes a wrapper for the specified I2C peripheral.</div><div class="ttdef"><b>Definition</b> <a href="hierodule__i2c_8c_source.html#l00421">hierodule_i2c.c:421</a></div></div>
</div><!-- fragment --><p><br  />
And you're good to go. Now your wrapper can handle comm requests from masters, perform the callback routines you've assigned to the modes and update the slave receiver buffer when a master is done transmitting data. You can parse the data received as slave via <a class="el" href="group___i2_c___public.html#ga06b9d9d82e83fce36e654d6bf9ae82ea">HIERODULE_I2C_GetNextByte</a>. <br  />
<br  />
To transmit data as master, call the master transmit routine with your wrapper, a slave address, a byte array and the number of bytes to be transmitted. </p><div class="fragment"><div class="line">uint8_t SlaveAddress = 0b01000101;</div>
<div class="line"> </div>
<div class="line">uint8_t MTX1_Buffer[6];</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> * ...</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group___i2_c___public.html#gafbdcebd2a181ad28bf0de98baec9e385">HIERODULE_I2C_MasterTransmit</a>(*My_I2C1_Wrapper, SlaveAddress, MTX1_Buffer, 6);</div>
<div class="ttc" id="agroup___i2_c___public_html_gafbdcebd2a181ad28bf0de98baec9e385"><div class="ttname"><a href="group___i2_c___public.html#gafbdcebd2a181ad28bf0de98baec9e385">HIERODULE_I2C_MasterTransmit</a></div><div class="ttdeci">void HIERODULE_I2C_MasterTransmit(HIERODULE_I2C_Wrapper *Wrapper, uint8_t SlaveAddress, uint8_t *MTX_Buffer, uint32_t Size)</div><div class="ttdoc">Puts the peripheral in master transmitter mode and handles the transmission.</div><div class="ttdef"><b>Definition</b> <a href="hierodule__i2c_8c_source.html#l00554">hierodule_i2c.c:554</a></div></div>
</div><!-- fragment --><p> <br  />
Receiving data from a slave is pretty similar. </p><div class="fragment"><div class="line">uint8_t MRX1_Buffer[12];</div>
<div class="line"><a class="code hl_function" href="group___i2_c___public.html#ga77594bd5a2b0caa2398eb06e3a4b8695">HIERODULE_I2C_MasterReceive</a>(*My_I2C1_Wrapper, SlaveAddress, MRX1_Buffer, 12);</div>
<div class="ttc" id="agroup___i2_c___public_html_ga77594bd5a2b0caa2398eb06e3a4b8695"><div class="ttname"><a href="group___i2_c___public.html#ga77594bd5a2b0caa2398eb06e3a4b8695">HIERODULE_I2C_MasterReceive</a></div><div class="ttdeci">void HIERODULE_I2C_MasterReceive(HIERODULE_I2C_Wrapper *Wrapper, uint8_t SlaveAddress, uint8_t *MRX_Buffer, uint32_t Size)</div><div class="ttdoc">Puts the peripheral in master receiver mode and handles the transmission.</div><div class="ttdef"><b>Definition</b> <a href="hierodule__i2c_8c_source.html#l00583">hierodule_i2c.c:583</a></div></div>
</div><!-- fragment --><p> You do not need to shift or set the LSB of the device address, the routines take care of that. <br  />
<br  />
You can "release" the instance of your wrapper to free memory: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group___i2_c___public.html#gad19d5f8ed1131e3908e19d508b8eb761">HIERODULE_I2C_ReleaseWrapper</a>(*My_I2C1_Wrapper); </div>
<div class="ttc" id="agroup___i2_c___public_html_gad19d5f8ed1131e3908e19d508b8eb761"><div class="ttname"><a href="group___i2_c___public.html#gad19d5f8ed1131e3908e19d508b8eb761">HIERODULE_I2C_ReleaseWrapper</a></div><div class="ttdeci">void HIERODULE_I2C_ReleaseWrapper(HIERODULE_I2C_Wrapper *Wrapper)</div><div class="ttdoc">Frees the memory allocated to an I2C wrapper.</div><div class="ttdef"><b>Definition</b> <a href="hierodule__i2c_8c_source.html#l00534">hierodule_i2c.c:534</a></div></div>
</div><!-- fragment --><p> Keep in mind this only frees the wrapper pointer in the module and not your double pointer that points to it. It's best to free and nullify that, as well: </p><div class="fragment"><div class="line">free(My_I2C1_Wrapper); </div>
</div><!-- fragment --> <div class="fragment"><div class="line">My_I2C1_Wrapper = NULL; </div>
</div><!-- fragment --><p> Notice that trying to access a freed memory address might turn out ugly for your run-time. However, you can reuse your double pointer to re-initialize the I2C peripheral after releasing it. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.0 </li>
  </ul>
</div>
</body>
</html>
